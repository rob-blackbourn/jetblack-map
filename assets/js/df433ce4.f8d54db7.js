"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7191],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return h}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),l=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=l(e.components);return r.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),d=l(n),h=o,g=d["".concat(s,".").concat(h)]||d[h]||p[h]||i;return n?r.createElement(g,a(a({ref:t},u),{},{components:n})):r.createElement(g,a({ref:t},u))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=d;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:o,a[1]=c;for(var l=2;l<i;l++)a[l]=n[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6098:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return s},default:function(){return h},frontMatter:function(){return c},metadata:function(){return l},toc:function(){return p}});var r=n(7462),o=n(3366),i=(n(7294),n(3905)),a=["components"],c={sidebar_position:7},s="Dragging",l={unversionedId:"hooks/dragging",id:"hooks/dragging",title:"Dragging",description:"Dragging the map is achieved by changing the center coordinate. When",source:"@site/docs/hooks/dragging.md",sourceDirName:"hooks",slug:"/hooks/dragging",permalink:"/jetblack-map/docs/hooks/dragging",draft:!1,editUrl:"https://github.com/rob-blackbourn/jetblack-map/tree/main/website/docs/hooks/dragging.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Coordinate Systems",permalink:"/jetblack-map/docs/hooks/coordinate-systems"},next:{title:"Clicking",permalink:"/jetblack-map/docs/hooks/clicking"}},u={},p=[],d={toc:p};function h(e){var t=e.components,n=(0,o.Z)(e,a);return(0,i.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"dragging"},"Dragging"),(0,i.kt)("p",null,"Dragging the map is achieved by changing the center coordinate. When\na drag happens the center moves from the last pointer location to the\ncurrent."),(0,i.kt)("p",null,"The built in hook deals with this as follows. It assumes the previous\nmouse point (",(0,i.kt)("inlineCode",{parentName:"p"},"lastPoint"),") has been saved, the ",(0,i.kt)("inlineCode",{parentName:"p"},"currentPoint")," is the\ninput, and the current ",(0,i.kt)("inlineCode",{parentName:"p"},"center")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"zoom")," is available. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"  const screenDelta: Point = {\n    x: (lastPoint.x - currentPoint.x),\n    y: (lastPoint.y - currentPoint.y),\n  }\n  const tileDelta: Point = {\n    x: screenDelta.x / tileWidth,\n    y: screenDelta.y / tileHeight,\n  }\n  const tile = coordinateToTilePoint(center, zoom)\n  const newTileCenter = {\n    x: tile.x + tileDelta.x,\n    y: tile.y + tileDelta.y,\n  }\n  const newCenter = tilePointToCoordinate(newTileCenter, zoom)\n  lastPoint = currentPoint\n  setCenter(newCenter)\n")),(0,i.kt)("p",null,"This is pseudo code of the ",(0,i.kt)("inlineCode",{parentName:"p"},"useDrag")," hook. The approach taken here\nis to take the change in position in the screen coordinate system,\nand convert it to the tile coordinate system. The current center is\nalso converted ot the tile coordinate system. The tile delta is then\nadded to the tile center to give a new tile center. Finally the new\ntile center is converted to a longitude and latitude."),(0,i.kt)("p",null,"Other approaches could have been used, the important attribute is that\nthe pointer movement should be consistent to the change in longitude\nand latitude."))}h.isMDXComponent=!0}}]);